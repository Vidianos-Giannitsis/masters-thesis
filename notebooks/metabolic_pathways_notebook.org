#+TITLE: Notebook for metabolic pathway prediction

* Table of Contents                                            :TOC:noexport:
- [[#description-of-the-core-concepts][Description of the core concepts]]
- [[#primitives][Primitives]]
  - [[#molar-mass-definition][Molar mass definition]]
  - [[#molar-mass-of-substances-used][Molar mass of substances used]]
  - [[#concentration-to-mass][Concentration to mass]]
- [[#core-pathways][Core pathways]]
  - [[#initial-state][Initial state]]
  - [[#glycolysis-definition-and-explanation][Glycolysis definition and explanation]]
  - [[#other-sugars][Other sugars]]
- [[#pathways-of-pyruvate-consumption][Pathways of pyruvate consumption]]
- [[#other-pathways-stemming-from-glycolysis][Other pathways stemming from glycolysis]]
- [[#other-pathways-for-glucose-consumption][Other pathways for glucose consumption]]
  - [[#heterolactic-fermentation][Heterolactic fermentation]]
  - [[#bifidus-fermentation][Bifidus fermentation]]
  - [[#ethanol-fermentation][Ethanol fermentation]]
  - [[#glucose-consumption][Glucose consumption]]
  - [[#aerobic-consumption][Aerobic consumption]]
- [[#acetogenic-routes][Acetogenic routes]]
- [[#common-fermentative-pathways][Common fermentative pathways]]
  - [[#abe-fermentation][ABE Fermentation]]
- [[#test-on-experiments][Test on experiments]]
  - [[#parameterized-final-metabolic-pathway][Parameterized final metabolic pathway]]
  - [[#finding-the-true-metabolic-pathway][Finding the true metabolic pathway]]
- [[#running-the-optimization-routine-for-the-other-9-experiments][Running the optimization routine for the other 9 experiments]]

* Description of the core concepts
This notebook is about a personal project of mine, which is mostly done as a learning experience in Julia, but if succesful can have application in my thesis (hence why it is in this directory). The idea is that since we know from literature every pathway a mixed culture fermentation can follow, if we have data for the input and output of either a continuous (in steady state) or batch reactor, we can try to find which pathways were followed and to what extent in each case.

This example can be made into an optimization problem as the extent to which each pathway is followed can be considered the parameters of the simulator and with an L2 loss between experimental data and the output of the simulator, we can optimize it with the classic SciML toolchain.

This can be very useful both for understanding the behaviour of a mixed culture of microorganisms and how they behave in different conditions but also can have very large application in modelling. Modelling mixed cultures is in general fairly hard because of the large amount of processes that can happen, but if we can quantify to what extent each process happens, it makes modelling much easier.

* Primitives
** Molar mass definition
Since we generally measure concentration in g/l, but reactions are described in molar terms, a very important primitive to implement is molar mass. We define molar mass for a general C_{a}H_{b}O_{c}N_{d}S_{e} compound with the function

#+NAME: molar_mass
#+BEGIN_SRC julia :tangle ../src/metabolic_pathways/primitives.jl
# Primitive to calculate molar mass
function molar_mass(; C=0, H=0, O=0, N=0, S=0)
mass = 12C + H + 16O + 14N + 32S
end

#+END_SRC

** Molar mass of substances used
and then calculate molar mass for all substances used in the system.

#+NAME: substance_molar_mass
#+BEGIN_SRC julia :tangle ../src/metabolic_pathways/primitives.jl

  # Calculate the molar masses of all used substances
  function m_glucose()
  molar_mass(C=6, H=12, O=6)
  end

  function m_fructose()
  molar_mass(C=6, H=12, O=6)
  end

  function m_sucrose()
  molar_mass(C=12, H=24, O=12)
  end

  function m_pyruvate()
  molar_mass(C=3, H=4, O=3)
  end

  function m_hydrogen()
  molar_mass(H=2)
  end

  function m_oxygen()
      molar_mass(O=2)
  end

  function m_co2()
  molar_mass(C=1, O=2)
  end

  function m_water()
  molar_mass(H=2, O=1)
  end

  function m_acetate()
  molar_mass(C=2, H=4, O=2)
  end

  function m_propionate()
  molar_mass(C=3, H=6, O=2)
  end

  function m_butyrate()
  molar_mass(C=4, H=8, O=2)
  end

  function m_ethanol()
  molar_mass(C=2, H=6, O=1)
  end

  function m_lactate()
  molar_mass(C=3, H=6, O=3)
  end

  function m_succinate()
  molar_mass(C=4, H=6, O=4)
  end

  function m_formate()
  molar_mass(C=1, H=2, O=2)
  end

  function m_acetaldehyde()
  molar_mass(C=2, H=4, O=1)
  end

  function m_acetone()
  molar_mass(C=3, H=6, O=1)
  end

  function m_butanol()
  molar_mass(C=4, H=10, O=1)
  end

  function m_valerate()
  molar_mass(C=5, H=10, O=2)
  end

#+END_SRC

** Concentration to mass
Since we define molar mass, we can easily convert moles to mass and opposite. However, what we typically measure is concentration, so we also need a function to convert mass to concentration, which is easy as concentration to mass is multiplication with volume and the opposite is division. This is shown below

#+NAME: conc_to_mass
#+BEGIN_SRC julia :tangle ../src/metabolic_pathways/primitives.jl

  function conc_to_mass(st, volume)
  new_st = NamedTuple{keys(st)}(values(st).*volume)
  end

  function mass_to_conc(st, volume)
  new_st = NamedTuple{keys(st)}(values(st)./volume)
  end

#+END_SRC

* Core pathways
Then, we can start writing down the metabolic pathways which can happen in this system. The concept is that they all operate in a variable named st (state), which is a named tuple holding the concentration of each compound and return a new state of how the concentrations changed due to this process. Furthermore, they all have one (or multiple) goals, which describe to what extent each reaction is followed.

** Initial state
Therefore, we first need an initial state. A test state used for a lot of what is implemented here is displayed below.

#+NAME: initial_state
#+BEGIN_SRC julia :tangle ../src/metabolic_pathways/core_pathways.jl

  state = (glucose = 16.0, pyruvate = 0.0, hydrogen = 0.0, water = 700.0, co2 = 0.0,
	  acetate = 0.0, propionate = 0.0, butyrate = 0.0, ethanol = 0.0,
	  lactate = 0.0, succinate = 0.0, formate = 0.0, acetaldehyde = 0.0,
	  fructose = 0.0, sucrose = 0.0, butanol = 0.0, acetone = 0.0,
	  valerate = 0.0, oxygen = 0.0)

#+END_SRC

** Glycolysis definition and explanation
After that, we can start writing down reactions. The first reaction we define is glycolysis, the pathway through which glucose is converted to pyruvate, hydrogen and energy. 

#+NAME: glycolysis
#+BEGIN_SRC julia :tangle ../src/metabolic_pathways/core_pathways.jl

  function glycolysis(st; goal = (; glucose = 0.0))
  stoic = (glucose = -1, pyruvate = +2, hydrogen = +2)
  mass_stoic = (glucose = stoic.glucose*m_glucose(),
		  pyruvate = stoic.pyruvate*m_pyruvate(),
		  hydrogen = stoic.hydrogen*m_hydrogen())
  goal.glucose <= st.glucose || error("Glucose is not sufficient for this goal")
  change = (goal.glucose - st.glucose)/mass_stoic.glucose
  new_st = merge(st,
		  (glucose = goal.glucose,
		  pyruvate = st.pyruvate + change*mass_stoic.pyruvate,
		  hydrogen = st.hydrogen + change*mass_stoic.hydrogen))
  end

#+END_SRC

The logic of the function is we define the stoichiometry, which is known, convert it to mass stoichiometry with the molar mass primitives defined above, find the factor ~change~ which calculates the conversion of the reaction in mass terms, from the goal given and update the state so that all compounds are changed by this variable times the mass stoichiometric coefficient. For the variable for which goal is defined, its value can more simply be the value of goal. It also runs an error check if the goal of glucose is larger than the glucose in the initial state. Since it is consumed, it cannot be more than its initial value, so the function should give an error if this is given. The logic of all other core reactions is the same, so it won't be explained again below. 

** Other sugars
However, in a lot of cases we don't have only glucose. The case study I am doing contains sucrose and fructose, but other sugars could be similarly defined. Sucrose is hydrolyzed to an equimolar mixture of glucose and fructose, while fructose enters the EMP pathway (glycolysis) producing glyceraldehyde-3-phosphate, which is an intermediate of pyruvate. Since this system tries to look at a bigger picture and not every intermediate of the process, the implementation of fructolysis will be that fructose isomerises to glucose and goes through glycolysis. Theoretically it is not correct, but with the amount of abstracted detail we have assumed, it does not give any error. Below are there implementations.

#+NAME: other_sugars
#+BEGIN_SRC julia :tangle ../src/metabolic_pathways/core_pathways.jl

  function sucrose_hydrolysis(st; goal = (; sucrose = 0.0))
  stoic = (sucrose = -1, glucose = +1, fructose = +1)
  mass_stoic = (sucrose = stoic.sucrose*m_sucrose(),
		  glucose = stoic.glucose*m_glucose(),
		  fructose = stoic.fructose*m_fructose())
  goal.sucrose <= st.sucrose || error("Sucrose is not sufficient for this goal")
  change = (goal.sucrose - st.sucrose)/mass_stoic.sucrose
  new_st = merge(st,
		  (sucrose = goal.sucrose,
		  glucose = st.glucose + change*mass_stoic.glucose,
		  fructose = st.fructose + change*mass_stoic.fructose))
  end

  function fructolysis(st; goal = (; fructose = 0.0))
  stoic = (fructose = -1, glucose = +1)
  mass_stoic = (fructose = stoic.fructose*m_fructose(),
		  glucose = stoic.glucose*m_glucose())
  goal.fructose <= st.fructose || error("Fructose is not sufficient for this goal")
  change = (goal.fructose - st.fructose)/mass_stoic.fructose
  fruc_st = merge(st,
		  (fructose = goal.fructose,
		  glucose = st.glucose + change*mass_stoic.glucose))
  new_st = glycolysis(fruc_st, goal = (; glucose = st.glucose))
  end

#+END_SRC

* Pathways of pyruvate consumption
As mentioned, pyruvate is the core intermediate of the process, produced during glycolysis. There are many pathways it can partake in, producing different products depending on conditions. The core ones (abstracting intermediates of the processes) are:

- Pyruvate + Water -> Acetate + CO2 + H2
- Pyruvate -> Acetaldehyde + CO2
- 2Pyruvate -> Butyrate + 2CO2
- Pyruvate + H2 -> Lactate
- Pyruvate + CO2 + H2 -> Succinate
- 2Pyruvate + 2H_2 -> Water + Butanol + 2CO_2
- 2Pyruvate + Water -> 3CO2 + 2H_2 + Acetone

#+NAME: pyruvate_consumption
#+BEGIN_SRC julia :tangle ../src/metabolic_pathways/core_pathways.jl


  function pyruv_to_acetate(st; goal = (; pyruvate = 0.0))
  stoic = (pyruvate = -1, water = -1, acetate= +1, hydrogen = +1, co2=+1)
  mass_stoic = (pyruvate = stoic.pyruvate*m_pyruvate(),
		  water = stoic.water*m_water(),
		  acetate = stoic.acetate*m_acetate(),
		  hydrogen = stoic.hydrogen*m_hydrogen(),
		  co2 = stoic.co2*m_co2())
  goal.pyruvate <= st.pyruvate || error("Pyruvate is not sufficient for this goal")
  change = (goal.pyruvate - st.pyruvate)/mass_stoic.pyruvate
  new_st = merge(st,
		  (pyruvate = goal.pyruvate,
		  water = st.water + change*mass_stoic.water,
		  acetate = st.acetate + change*mass_stoic.acetate,
		  hydrogen = st.hydrogen + change*mass_stoic.hydrogen,
		  co2 = st.co2 + change*mass_stoic.co2))
  end

  function pyruv_to_acetaldehyde(st; goal = (; pyruvate = 0.0))
  stoic = (pyruvate = -1, acetaldehyde = +1, co2 = +1)
  mass_stoic = (pyruvate = stoic.pyruvate*m_pyruvate(),
		  acetaldehyde = stoic.acetaldehyde*m_acetaldehyde(),
		  co2 = stoic.co2*m_co2())
  goal.pyruvate <= st.pyruvate || error("Pyruvate is not sufficient for this goal")
  change = (goal.pyruvate - st.pyruvate)/mass_stoic.pyruvate
  new_st = merge(st,
		  (pyruvate = goal.pyruvate,
		  acetaldehyde = st.acetaldehyde + change*mass_stoic.acetaldehyde,
		  co2 = st.co2 + change*mass_stoic.co2))
  end


  function pyruv_to_butyr(st; goal = (; pyruvate = 0.0))
  stoic = (pyruvate = -2, butyrate = +1, co2 = +2)
  mass_stoic = (pyruvate = stoic.pyruvate*m_pyruvate(),
		  butyrate = stoic.butyrate*m_butyrate(),
		  co2 = stoic.co2*m_co2())
  goal.pyruvate <= st.pyruvate || error("Pyruvate is not sufficient for this goal")
  change = (goal.pyruvate - st.pyruvate)/mass_stoic.pyruvate
  new_st = merge(st,
		  (pyruvate = goal.pyruvate,
		  butyrate = st.butyrate + change*mass_stoic.butyrate,
		  co2 = st.co2 + change*mass_stoic.co2))
  end

  function pyruv_to_butanol(st; goal = (; pyruvate = 0.0))
  stoic = (pyruvate = -2, hydrogen = -2, water = +1, butanol = +1, co2 = +2)
  mass_stoic = (pyruvate = stoic.pyruvate*m_pyruvate(),
		  hydrogen = stoic.hydrogen*m_hydrogen(),
		  water = stoic.water*m_water(),
		  butanol = stoic.butanol*m_butanol(),
		  co2 = stoic.co2*m_co2())
  goal.pyruvate <= st.pyruvate || error("Pyruvate is not sufficient for this goal")
  change = (goal.pyruvate - st.pyruvate)/mass_stoic.pyruvate
  abs(change*mass_stoic.hydrogen) <= st.hydrogen || error("Hydrogen is not sufficient for this goal")
  new_st = merge(st,
		  (pyruvate = goal.pyruvate,
		  butanol = st.butanol + change*mass_stoic.butanol,
		  hydrogen = st.hydrogen + change*mass_stoic.hydrogen,
		  co2 = st.co2 + change*mass_stoic.co2,
		  water = st.water + change*mass_stoic.water))
  end

  function pyruv_to_acetone(st; goal = (; pyruvate = 0.0))
  stoic = (pyruvate = -2, water = -1, co2 = +3, hydrogen = +2, acetone = +1)
  mass_stoic = (pyruvate = stoic.pyruvate*m_pyruvate(),
		  water = stoic.water*m_water(),
		  hydrogen = stoic.hydrogen*m_hydrogen(),
		  co2 = stoic.co2*m_co2(),
		  acetone = stoic.acetone*m_acetone())
  goal.pyruvate <= st.pyruvate || error("Pyruvate is not sufficient for this goal")
  change = (goal.pyruvate - st.pyruvate)/mass_stoic.pyruvate
  new_st = merge(st,
		  (pyruvate = goal.pyruvate,
		  water = st.water + change*mass_stoic.water,
		  co2 = st.co2 + change*mass_stoic.co2,
		  hydrogen = st.hydrogen + change*mass_stoic.hydrogen,
		  acetone = st.acetone + change*mass_stoic.acetone))
  end

  function pyruv_to_lact(st; goal = (; pyruvate = 0.0))
  stoic = (pyruvate = -1, hydrogen = -1, lactate = +1)
  mass_stoic = (pyruvate = stoic.pyruvate*m_pyruvate(),
		  hydrogen = stoic.hydrogen*m_hydrogen(),
		  lactate = stoic.lactate*m_lactate())
  goal.pyruvate <= st.pyruvate || error("Pyruvate is not sufficient for this goal")
  change = (goal.pyruvate - st.pyruvate)/mass_stoic.pyruvate
  abs(change*mass_stoic.hydrogen) <= st.hydrogen || error("Hydrogen is not sufficient for this goal")
  new_st = merge(st,
		  (pyruvate = goal.pyruvate,
		  hydrogen = st.hydrogen + change*mass_stoic.hydrogen,
		  lactate = st.lactate + change*mass_stoic.lactate))
  end


  function pyruv_to_succin(st; goal = (; pyruvate = 0.0))
  stoic = (pyruvate = -1, co2 = -1, hydrogen = -2, succinate = +1, water = +1)
  mass_stoic = (pyruvate = stoic.pyruvate*m_pyruvate(),
		  co2 = stoic.co2*m_co2(),
		  hydrogen = stoic.hydrogen*m_hydrogen(),
		  succinate = stoic.succinate*m_succinate(),
		  water = stoic.water*m_water())
  goal.pyruvate <= st.pyruvate || error("Pyruvate is not sufficient for this goal")
  change = (goal.pyruvate - st.pyruvate)/mass_stoic.pyruvate
  abs(change*mass_stoic.hydrogen) <= st.hydrogen || error("Hydrogen is not sufficient for this goal")
  abs(change*mass_stoic.co2) <= st.co2 || error("CO2 is not sufficient for this goal")
  new_st = merge(st,
		  (pyruvate = goal.pyruvate,
		  co2 = st.co2 + change*mass_stoic.co2,
		  hydrogen = st.hydrogen + change*mass_stoic.hydrogen,
		  succinate = st.succinate + change*mass_stoic.succinate,
		  water = st.water + change*mass_stoic.water))
  end 

#+END_SRC

* Other pathways stemming from glycolysis
However, there are also some other important reactions that are in these pathways as the above products are in some cases intermediates for the production of something else. The reactions taking some of these products and converting them to other products are: 

- Acetaldehyde + H2 -> Ethanol
- Lactate + H2 -> Propionate
- Succinate + CO2 -> Propionate
- Formate <-> CO2 + H2
- Propionate + 2CO2 + 6H2 -> Valerate

and the code for their implementation can be seen below
#+NAME: other_core_pathways
#+BEGIN_SRC julia :tangle ../src/metabolic_pathways/core_pathways.jl


  function acetaldehyde_to_ethanol(st; goal = (; acetaldehyde = 0.0))
  stoic = (acetaldehyde = -1, hydrogen = -1, ethanol = +1)
  mass_stoic = (acetaldehyde = stoic.acetaldehyde*m_acetaldehyde(),
		  hydrogen = stoic.hydrogen*m_hydrogen(),
		  ethanol = stoic.ethanol*m_ethanol())
  goal.acetaldehyde <= st.acetaldehyde || error("Acetaldehyde is not sufficient for this goal")
  change = (goal.acetaldehyde - st.acetaldehyde)/mass_stoic.acetaldehyde
  abs(change*mass_stoic.hydrogen) <= st.hydrogen || error("Hydrogen is not sufficient for this goal")
  new_st = merge(st,
		  (acetaldehyde = goal.acetaldehyde,
		  hydrogen = st.hydrogen + change*mass_stoic.hydrogen,
		  ethanol = st.ethanol + change*mass_stoic.ethanol))
  end


  function lact_to_propionate(st; goal = (; lactate = 0.0))
  stoic = (lactate = -1, hydrogen = -1, propionate = +1)
  mass_stoic = (lactate = stoic.lactate*m_lactate(),
		  hydrogen = stoic.hydrogen*m_hydrogen(),
		  propionate = stoic.propionate*m_propionate())
  goal.lactate <= st.lactate || error("Lactate is not sufficient for this goal")
  change = (goal.lactate - st.lactate)/mass_stoic.lactate
  abs(change*mass_stoic.hydrogen) <= st.hydrogen || error("Hydrogen is not sufficient for this goal")
  new_st = merge(st,
		  (lactate = goal.lactate,
		  hydrogen = st.hydrogen + change*mass_stoic.hydrogen,
		  propionate = st.propionate + change*mass_stoic.propionate))
  end


  function succin_to_propionate(st; goal = (; succinate = 0.0))
  stoic = (succinate = -1, propionate = +1, co2 = +1)
  mass_stoic = (succinate = stoic.succinate*m_succinate(),
		  propionate = stoic.propionate*m_propionate(),
		  co2 = stoic.co2*m_co2())
  goal.succinate <= st.succinate || error("Succinate is not sufficient for this goal")
  change = (goal.succinate - st.succinate)/mass_stoic.succinate
  new_st = merge(st,
		  (succinate = goal.succinate,
		  propionate = st.propionate + change*mass_stoic.propionate,
		  co2 = st.co2 + change*mass_stoic.co2))
  end

  # The formate balance isn't exactly like all the other reactions where
  # the goal is the main reactant. It is a reaction very close to
  # equilibrium that in pH near neutral or higher is favored on
  # formate. If you expect that formate will be produced, you can give a
  # goal that formate has this concentration and it will remove enough
  # co2 and hydrogen for it to be feasible. Since it is common for none
  # to be produced, the default value will be expect that none will be
  # produced.
  function formate_balance(st; goal = (; formate = 0.0))
  stoic = (co2 = -1, hydrogen = -1, formate = +1)
  mass_stoic = (co2 = stoic.co2*m_co2(),
		  hydrogen = stoic.hydrogen*m_hydrogen(),
		  formate = stoic.formate*m_formate())
  change = (goal.formate - st.formate)/mass_stoic.formate
  abs(change*mass_stoic.hydrogen) <= st.hydrogen || error("Hydrogen is not sufficient for this goal")
  abs(change*mass_stoic.co2) <= st.co2 || error("CO2 is not sufficient for this goal")
  new_st = merge(st,
		  (formate = goal.formate,
		  co2 = st.co2 + change*mass_stoic.co2,
		  hydrogen = st.hydrogen + change*mass_stoic.hydrogen))
  end


  function propionate_to_valerate(st; goal = (; valerate = 0.0))
  stoic = (propionate = -1, co2 = -2, hydrogen = -6, valerate =+1)
  mass_stoic = (propionate = stoic.propionate*m_propionate(),
		  co2 = stoic.co2*m_co2(),
		  hydrogen = stoic.hydrogen*m_hydrogen(),
		  valerate = stoic.valerate*m_valerate())
  goal.valerate <= m_valerate()*st.propionate/m_propionate() || error("Propionate is not sufficient for this goal")
  change = (goal.valerate - st.valerate)/mass_stoic.valerate
  new_st = merge(st,
		  (valerate = goal.valerate,
		  propionate = st.propionate + change*mass_stoic.propionate,
		  co2 = st.co2 + change*mass_stoic.co2,
		  hydrogen = st.hydrogen + change*mass_stoic.hydrogen))
  end

#+END_SRC

With these implemented, we might want to write down the complete reaction of pyruvate to ethanol since we know it can be done through acetaldehyde. This is a rather simple implementation as it just sequentially runs the two functions.

#+NAME: pyruv_to_ethanol
#+BEGIN_SRC julia :tangle ../src/metabolic_pathways/compound_pathways.jl

  function pyruv_to_ethanol(st; pyr_goal = (; pyruvate = 0.0),
			  acet_goal = (; acetaldehyde = 0.0))
  acetaldehyde_st = pyruv_to_acetaldehyde(st, goal = pyr_goal)
  new_st = acetaldehyde_to_ethanol(acetaldehyde_st, goal = acet_goal)
  end

#+END_SRC

A more complex one is the pathway that goes from pyruvate to propionate. Propionate can be produced from lactate as the intermediate or from succinate, with both having the same end result. We can write a more complex composition function which takes both pathways and the extent to which each is followed, which might be of interest. For this implementation, we follow a similar logic as above, with one more important step. One of our inputs is the amount of pyruvate that goes to lactate production (since there are two pathways, the other is 1-lactate). Since we know how much pyruvate goes to each reaction, we can change the goal of each function to not consume all the pyruvate, but only the one we define. If we want all the pyruvate to be consumed by this reaction and we want each intermediate to only take an amount, this is simple as it is just the initial pyruvate times the amount. However, since this compound reaction might be used in other larger composition reactions, we want a behaviour that works even if the pyruvate goal of the total reaction is non zero. This expression turns out to be [st.pyruvate - (st.pyryvate - goal.pyruvate)*lact_amount] and is used extensively below in all compound pathways that will be defined. Another important thing in this function is the final composition. Since reactions don't occur serially but simultaneously, we need to merge them together. However, in the case where what is being created in the reaction already existed in the reactor, each state will have the initial amount and add to it what was produced/consumed in it. Therefore, to get correct results, if 2 (or more in other more complex pathways) reactions produce the same thing, we must always substract the initial value to not inflate them. The definition can be seen below.

#+NAME: pyruv_to_propionate
#+BEGIN_SRC julia :tangle ../src/metabolic_pathways/compound_pathways.jl

  function pyruv_to_propionate(st, lact_amount; pyr_goal = (; pyruvate = 0.0),
			      succin_goal = (; succinate = 0.0),
			      lact_goal = (; lactate = 0.0))
  lact_prod_goal = (; pyruvate = (st.pyruvate - (st.pyruvate - pyr_goal.pyruvate)*lact_amount))
  succin_prod_goal = (; pyruvate = (st.pyruvate - (st.pyruvate - pyr_goal.pyruvate)*(1-lact_amount)))

  lact_st = pyruv_to_lact(st, goal = lact_prod_goal)
  succin_st = pyruv_to_succin(st, goal = succin_prod_goal)
  new_st = merge(st,
		  (pyruvate = pyr_goal.pyruvate,
		      hydrogen = st.hydrogen - (st.hydrogen - succin_st.hydrogen) - (st.hydrogen - lact_st.hydrogen),
		      co2 = succin_st.co2,
		      succinate = succin_st.succinate,
		      lactate = lact_st.lactate))

  prop_st1 = lact_to_propionate(new_st, goal = lact_goal)
  prop_st2 = succin_to_propionate(new_st, goal = succin_goal)

  final_st = merge(new_st,
		      (lactate = lact_goal.lactate,
		      succinate = succin_goal.succinate,
		      propionate = prop_st1.propionate + prop_st2.propionate - new_st.propionate,
		      hydrogen = prop_st1.hydrogen,
		      co2 = prop_st2.co2))
  end

#+END_SRC

* Other pathways for glucose consumption
However, the glycolytic pathway for pyruvate production and its conversion to products isn't the only possible route. There are also other pathways for the consumption of glucose.

** Heterolactic fermentation
One such pathway is the PK pathway where glucose is converted to one mole of glyceraldehyde-3-phosphate (which is then converted to pyruvate) and one mole of acetyl-CoA. This route produces 3 hydrogen moles together with those, which means that reductions are heavily favored. For this reason, the pyruvate produced is converted to lactate and acetyl-CoA favors the reductive pathway of ethanol production instead of acetate, although acetate can be seen in this pathway. This is also called the heterolactic fermentation pathway due to how lactate is produced together with a co-product. The two primitive reactions for heterolactate with ethanol and acetate are defined and then a compound reaction that combines them.

#+NAME: heterolactic_fermentation
#+BEGIN_SRC julia :tangle ../src/metabolic_pathways/core_pathways.jl

  function ethanol_heterolactate(st; goal = (; glucose = 0.0))
  stoic = (glucose = -1, pyruvate = +1, ethanol = +1, hydrogen = +1, co2 = +2)
  mass_stoic = (glucose = stoic.glucose*m_glucose(),
		  pyruvate = stoic.pyruvate*m_pyruvate(),
		  ethanol = stoic.ethanol*m_ethanol(),
		  hydrogen = stoic.hydrogen*m_hydrogen(),
		  co2 = stoic.co2*m_co2())
  goal.glucose <= st.glucose || error("Glucose is not sufficient for this goal")
  change = (goal.glucose - st.glucose)/mass_stoic.glucose
  pyr_st = merge(st,
		  (glucose = goal.glucose,
		  pyruvate = st.pyruvate + change*mass_stoic.pyruvate,
		  ethanol = st.ethanol + change*mass_stoic.ethanol,
		  hydrogen = st.hydrogen + change*mass_stoic.hydrogen,
		  co2 = st.co2 + change*mass_stoic.co2))

  new_st = pyruv_to_lact(pyr_st)
  end

  function acetate_heterolactate(st; goal = (; glucose = 0.0))
  stoic = (glucose = -1, pyruvate = +1, acetate = +1, hydrogen = +3, co2 = +2)
  mass_stoic = (glucose = stoic.glucose*m_glucose(),
		  pyruvate = stoic.pyruvate*m_pyruvate(),
		  acetate = stoic.acetate*m_acetate(),
		  hydrogen = stoic.hydrogen*m_hydrogen(),
		  co2 = stoic.co2*m_co2())
  goal.glucose <= st.glucose || error("Glucose is not sufficient for this goal")
  change = (goal.glucose - st.glucose)/mass_stoic.glucose
  pyr_st = merge(st,
		  (glucose = goal.glucose,
		  pyruvate = st.pyruvate + change*mass_stoic.pyruvate,
		  acetate = st.acetate + change*mass_stoic.acetate,
		  hydrogen = st.hydrogen + change*mass_stoic.hydrogen,
		  co2 = st.co2 + change*mass_stoic.co2))

  new_st = pyruv_to_lact(pyr_st)
  end


  function heterolactic_ferment(st; goal = (; glucose = 0.0),
			      acet_amount = 0)
  acet_prod_goal = (; glucose = (st.glucose - (st.glucose - goal.glucose)*acet_amount))
  eth_prod_goal = (; glucose = (st.glucose - (st.glucose - goal.glucose)*(1-acet_amount)))

  eth_st = ethanol_heterolactate(st, goal)
  acet_st = acetate_heterolactate(st, goal)
  new_st = merge(st,
		  (glucose = goal.glucose,
		  ethanol = eth_st.ethanol,
		  acetate = acet_st.acetate,
		  lactate = eth_st.lactate + acet_st.lactate - st.lactate,
		  co2 = eth_st.co2 + acet_st.co2 - st.co2,
		  hydrogen = eth_sth.hydrogen + acet_st.hydrogen - st.hydrogen))
  end

#+END_SRC

** Bifidus fermentation
Another possible pathway is bifidus fermentation where 1/4th of the glucose is converted immediately to acetyl-CoA (half a molecule) and the rest of the carbons (5) go through a different pathway to pyruvate and acetyl-CoA. However, in this process, only one hydrogen is produced (oxidation of glyceraldehyde-3-phosphate to pyruvate) so pathways of reduction are not as favored and acetyl-CoA is converted to acetate. The common co-product however remains lactate using the one hydrogen created from pyruvate.

#+NAME: bifidus
#+BEGIN_SRC julia :tangle ../src/metabolic_pathways/core_pathways.jl

  function bifidus_ferment(st; goal = (; glucose = 0.0))
  stoic = (glucose = -1, acetate = +1.5, pyruvate = +1, hydrogen = +1)
  mass_stoic = (glucose = stoic.glucose*m_glucose(),
		  acetate = stoic.acetate*m_acetate(),
		  pyruvate = stoic.pyruvate*m_pyruvate(),
		  hydrogen = stoic.hydrogen*m_hydrogen())
  goal.glucose <= st.glucose || error("Glucose is not sufficient for this goal")
  change = (goal.glucose - st.glucose)/mass_stoic.glucose
  pyr_st = merge(st,
		  (glucose = goal.glucose,
		  pyruvate = st.pyruvate + change*mass_stoic.pyruvate,
		  acetate = st.acetate + change*mass_stoic.acetate,
		  hydrogen = st.hydrogen + change*mass_stoic.hydrogen))

  new_st = pyruv_to_lact(pyr_st)
  end

#+END_SRC

** Ethanol fermentation
Another common pathway of glucose consumption is the ethanol fermentation which happens in yeasts. This is not very common in a typical mixed culture, but is added here for completion purposes and due to how easy it is to implement.

#+NAME: ethanol
#+BEGIN_SRC julia :tangle ../src/metabolic_pathways/core_pathways.jl


  function ethanol_fermentation(st; goal = (; glucose = 0.0))
  stoic = (glucose = -1, ethanol = +2, co2 = +2)
  mass_stoic = (glucose = stoic.glucose*m_glucose(),
		  ethanol = stoic.ethanol*m_ethanol(),
		  co2 = stoic.co2*m_co2())
  goal.glucose <= st.glucose || error("Glucose is not sufficient for this goal")
  change = (goal.glucose - st.glucose)/mass_stoic.glucose
  new_st = merge(st,
		  (glucose = goal.glucose,
		  ethanol = st.ethanol + change*mass_stoic.ethanol,
		  co2 = st.co2 + change*mass_stoic.co2))
  end

#+END_SRC

** Glucose consumption
Having defined 4 different pathways in which glucose is consumed, there is interest in defining a glucose consumption function which given the amount of glucose in each pathway can calculate the products. Then, this can be linked to pyruvate consumption pathways to final products. This is shown here.

#+NAME: glucose_consumption
#+BEGIN_SRC julia :tangle ../src/metabolic_pathways/compound_pathways.jl

  function glucose_consumption(st, bifidus_amount, eth_amount,
			      heterolact_amount; goal = (; glucose = 0.0),
			      acet_amount = 0)
  glycolysis_amount = 1-bifidus_amount-eth_amount-heterolact_amount
  bifidus_goal = (; glucose = (st.glucose - (st.glucose - goal.glucose))*bifidus_amount)
  eth_goal = (; glucose = (st.glucose - (st.glucose - goal.glucose))*eth_amount)
  heterolact_goal = (; glucose = (st.glucose - (st.glucose - goal.glucose))*heterolact_amount)
  glycolysis_goal = (; glucose = (st.glucose - (st.glucose - goal.glucose))*glycolysis_amount)

  bifidus_st = bifidus_ferment(st, goal)
  eth_st = ethanol_fermentation(st, goal)
  heterolact_st = heterolactic_ferment(st, goal = goal, acet_amount = acet_amount)
  glycolysis_st = glycolysis(st, goal)

  new_st = merge(st,
		  (glucose = goal.glucose,
		  pyruvate = glycolysis_st.pyruvate,
		  acetate = heterolact_st.acetate + bifidus_st.acetate - st.acetate,
		  ethanol = heterolact_st.ethanol + eth_st.ethanol - st.ethanol,
		  lactate = heterolact_st.lactate + bifidus_st.lactate - st.lactate,
		  co2 = heterolact_st.co2 + eth_st.co2 - st.co2,
		  hydrogen = glycolysis_st.hydrogen + heterolact_st.hydrogen))
  end

#+END_SRC

** Aerobic consumption
In aerobic conditions (with oxygen in the reactor), glucose goes down the glycolytic pathway, but pyruvate is not converted into any of the aforementioned products, but rather enters the Krebs cycle where it continuously produces energy, CO_{2} and hydrogen. Pyruvate is first converted to acetyl-CoA in this process (which abstracting the details of CoA can be simulated with the conversion to acetate we have written down) and then that breaks down to CO_{2} and hydrogen in the Krebs cycle. NAD^+ and FAD is required for this process and for it to be in its oxidized state all the time, this process needs to be done with oxygen. By the electron balance of these, 2 moles of oxygen are required per run of the Krebs cycle. Also 2 moles of water are necessary. Therefore, in our reaction system which abstracts the details of each pathway, it could be described as \( CH3COOH + 2 H_2O \xrightarrow{2O_2} 2 CO_{2} + 4H_2 \) where the Oxygen is written in the arrow becuase the redox reactions it participates in are hidden. Kreb's cycle operates for as long as there is oxygen in the reactor, therefore, the goal of this function will be oxygen to 0. However, if written as two reactions (pyruvate to acetate and acetate oxidation), we will get incorrect results, as we want pyruvate to acetate for as much as oxygen can be produced. Therefore, we need to combine the reactions. The implementation is shown below

#+NAME: aerobic_pyruvate_oxidation
#+BEGIN_SRC julia :tangle ../src/metabolic_pathways/core_pathways.jl

  function aerobic_pyruvate_oxidation(st; goal = (; oxygen = 0.0))
      stoic = (pyruvate = -1, water = -3, oxygen = -2, co2 = +3, hydrogen = +5)
      mass_stoic = (pyruvate = stoic.pyruvate*m_pyruvate(),
		    water = stoic.water*m_water(),
		    oxygen = stoic.oxygen*m_oxygen(),
		    co2 = stoic.co2*m_co2(),
		    hydrogen = stoic.hydrogen*m_hydrogen())
      goal.oxygen <= st.oxygen || error("Oxygen is not sufficient for this goal")
      change = (goal.oxygen - st.oxygen)/mass_stoic.oxygen
      abs(change*mass_stoic.pyruvate) <= st.pyruvate || error("Pyruvate is not sufficient for this goal")
      new_st = merge(st,
		     (oxygen = goal.oxygen,
		      pyruvate = st.pyruvate + change*mass_stoic.pyruvate,
		      water = st.water + change*mass_stoic.water,
		      co2 = st.co2 + change*mass_stoic.co2,
		      hydrogen = st.hydrogen + change*mass_stoic.hydrogen))
  end

#+END_SRC

* Acetogenic routes
Another big part of a typical anaerobic mixed culture fermentation is acetogenesis, the process in which various materials (such as propionate, butyrate, lactate, ethanol etc.) are converted to acetate. These processes are described below.

#+NAME: acetogenic_routes
#+BEGIN_SRC julia :tangle ../src/metabolic_pathways/acetogenesis.jl

  function propionate_to_acetate(st; goal = (; propionate = 0.0))
  stoic = (propionate = -1, water = -2, acetate = +1, co2 = +1, hydrogen = +3)
  mass_stoic = (propionate = stoic.propionate*m_propionate(),
		  water = stoic.water*m_water(),
		  acetate = stoic.acetate*m_acetate(),
		  co2 = stoic.co2*m_co2(),
		  hydrogen = stoic.hydrogen*m_hydrogen())
  goal.propionate <= st.propionate || error("Propionate is not sufficient for this goal")
  change = (goal.propionate - st.propionate)/mass_stoic.propionate
  new_st = merge(st,
		  (propionate = goal.propionate,
		  water = st.water + change*mass_stoic.water,
		  acetate = st.acetate + change*mass_stoic.acetate,
		  co2 = st.co2 + change*mass_stoic.co2,
		  hydrogen = st.hydrogen + change*mass_stoic.hydrogen))
  end

  function butyr_to_acetate(st; goal = (; butyrate = 0.0))
  stoic = (butyrate = -1, water = -2, acetate = +2, hydrogen = +2)
  mass_stoic = (butyrate = stoic.butyrate*m_butyrate(),
		  water = stoic.water*m_water(),
		  acetate = stoic.acetate*m_acetate(),
		  hydrogen = stoic.hydrogen*m_hydrogen())
  goal.butyrate <= st.butyrate || error("Butyrate is not sufficient for this goal")
  change = (goal.butyrate - st.butyrate)/mass_stoic.butyrate
  new_st = merge(st,
		  (butyrate = goal.butyrate,
		  water = st.water + change*mass_stoic.water,
		  acetate = st.acetate + change*mass_stoic.acetate,
		  hydrogen = st.hydrogen + change*mass_stoic.hydrogen))
  end

  function ethanol_to_acetate(st; goal = (; ethanol = 0.0))
      stoic = (ethanol = -1, water = -2, acetate = +1, hydrogen = +2)
      mass_stoic = (ethanol = stoic.ethanol*m_ethanol(),
		    water = stoic.water*m_water(),
		    acetate = stoic.acetate*m_acetate(),
		    hydrogen = stoic.hydrogen*m_hydrogen())
      goal.ethanol <= st.ethanol || error("Ethanol is not sufficient for this goal")
      change = (goal.ethanol - st.ethanol)/mass_stoic.ethanol
      new_st = merge(st,
		     (ethanol = goal.ethanol,
		      water = st.water + change*mass_stoic.water,
		      acetate = st.acetate + change*mass_stoic.acetate,
		      hydrogen = st.hydrogen + change*mass_stoic.hydrogen))
  end

  function lact_to_acetate(st; goal = (; lactate = 0.0))
      stoic = (lactate = -1, water = -1, acetate = +1, hydrogen = +2, co2 = +1)
      mass_stoic = (lactate = stoic.lactate*m_lactate(),
		    water = stoic.water*m_water(),
		    acetate = stoic.acetate*m_acetate(),
		    co2 = stoic.co2*m_co2(),
		    hydrogen = stoic.hydrogen*m_hydrogen())
      goal.lactate <= st.lactate || error("Lactate is not sufficient for this goal")
      change = (goal.lactate - st.lactate)/mass_stoic.lactate
      new_st = merge(st,
		     (lactate = goal.lactate,
		      water = st.water + change*mass_stoic.water,
		      acetate = st.acetate + change*mass_stoic.acetate,
		      co2 = st.co2 + change*mass_stoic.co2,
		      hydrogen = st.hydrogen + change*mass_stoic.hydrogen))
  end

  # In some cases, lactate acetogenesis can also happen together with
  # its reduction to propionate.

  function lact_to_acet_prop(st; goal = (; lactate = 0.0))
      stoic = (lactate = -2, acetate = +1, propionate = +1, hydrogen = +1, co2 = +1)
      mass_stoic = (lactate = stoic.lactate*m_lactate(),
		    acetate = stoic.acetate*m_acetate(),
		    co2 = stoic.co2*m_co2(),
		    propionate = stoic.propionate*m_propionate(),
		    hydrogen = stoic.hydrogen*m_hydrogen())
      goal.lactate <= st.lactate || error("Lactate is not sufficient for this goal")
      change = (goal.lactate - st.lactate)/mass_stoic.lactate
      new_st = merge(st,
		     (lactate = goal.lactate,
		      acetate = st.acetate + change*mass_stoic.acetate,
		      propionate = st.propionate + change*mass_stoic.propionate,
		      hydrogen = st.hydrogen + change*mass_stoic.hydrogen))
  end

  # For this reason, we can also define a compound reaction that lists
  # both pathways of lactate acetogenesis (conversion to acetate or
  # conversion to a mixture of it and propionate due to the surplus of
  # hydrogen allowing for lactate reduction) with the extent to which
  # the propionate producing reaction happens.

  function lactate_acetogenesis(st, prop_amount; goal = (; lactate = 0.0))
      acet_prod_goal = (; lactate = (st.lactate - (st.lactate - goal.lactate)*(1-prop_amount)))
      prop_prod_goal = (; lactate = (st.lactate - (st.lactate - goal.lactate)*prop_amount))

      acet_st = lact_to_acetate(st, goal = acet_prod_goal)
      prop_st = lact_to_acet_prop(st, goal = prop_prod_goal)
      new_st = merge(st,
		     (lactate = goal.lactate,
		      acetate = acet_st.acetate + prop_st.acetate - st.acetate,
		      hydrogen = acet_st.hydrogen + prop_st.hydrogen - st.hydrogen,
		      co2 = acet_st.co2 + prop_st.co2 - st.co2,
		      propionate = prop_st.propionate,
		      water = acet_st.water))
  end

  function homoacetogenic_acetate(st; goal = (; hydrogen = 0.0))
      stoic = (hydrogen = -4, co2 = -2, acetate = +1, water = +1)
      mass_stoic = (hydrogen = stoic.hydrogen*m_hydrogen(),
		    co2 = stoic.co2*m_co2(),
		    acetate = stoic.acetate*m_acetate(),
		    water = stoic.water*m_water())
      goal.hydrogen <= st.hydrogen || error("Hydrogen is not sufficient for this goal")
      abs(change*mass_stoic.co2) <= st.co2 || error("CO2 is not sufficient for this goal")
      change = (goal.hydrogen - st.hydrogen)/mass_stoic.hydrogen
      new_st = merge(st,
		     (hydrogen = goal.hydrogen,
		      co2 = st.co2 + change*mass_stoic.co2,
		      acetate = st.acetate + change*mass_stoic.acetate,
		      water = st.water + change*mass_stoic.water))
  end

#+END_SRC

After this is done, we can define a large compound reaction for acetogenesis that given the final mass of each material can find the final state that is reached. 

#+NAME: acetogenesis
#+BEGIN_SRC julia :tangle ../src/metabolic_pathways/acetogenesis.jl

  function acetogenesis(st; prop_goal = (; propionate = st.propionate),
			butyr_goal = (; butyrate = st.butyrate),
			eth_goal = (; ethanol = st.ethanol),
			lact_goal = (; lactate = st.lactate),
			hyd_goal = (; hydrogen = st.hydrogen),
			lact_prop = 0)
      prop_st = propionate_to_acetate(st, goal = prop_goal)
      butyr_st = butyr_to_acetate(st, goal = butyr_goal)
      eth_st = ethanol_to_acetate(st, goal = eth_goal)
      lact_st = lactate_acetogenesis(st, lact_prop, goal = lact_goal)

      new_st = merge(st,
		     (propionate = prop_st.propionate + lact_st.propionate - st.propionate,
		      butyrate = butyr_st.butyrate,
		      ethanol = eth_st.ethanol,
		      lactate = lact_st.lactate,
		      co2 = prop_st.co2 + lact_st.co2 - st.co2,
		      water = prop_st.water + butyr_st.water + eth_st.water + lact_st.water - 3st.water,
		      acetate = prop_st.acetate + butyr_st.acetate + eth_st.acetate + lact_st.acetate - 3st.acetate,
		      hydrogen = prop_st.hydrogen + butyr_st.hydrogen + eth_st.hydrogen + lact_st.hydrogen - 3st.hydrogen))

      #homoacetic_st = homoacetogenic_acetate(new_st, goal = hyd_goal)
  end

#+END_SRC

* Common fermentative pathways
After defining all the above, there is a lot of interest in some very common compound fermentative pathways. For example, we know from literature that a very common pathway is that ethanol and acetate are produced in equimolar amounts, so instead of writing that in the final function we want to use, we can implement it directly and then use this in the final function that describes the combination of pathways we assume to be followed. Besides acetate-ethanol fermentation, we know that a fermentation of butyrate with acetate in a 3:1 molar analogy is common and propionate-acetate in a 2:1.

#+NAME: common_pathways
#+BEGIN_SRC julia :tangle ../src/metabolic_pathways/compound_pathways.jl

  function acetate_ethanol_fermentation(st; goal = (; pyruvate = 0.0))
  acet_goal = (; pyruvate = (st.pyruvate - (st.pyruvate - goal.pyruvate)*0.5))
  eth_goal = (; pyruvate = (st.pyruvate - (st.pyruvate - goal.pyruvate)*0.5))

  acet_st = pyruv_to_acetate(st, goal = acet_goal)
  eth_st = pyruv_to_ethanol(st, pyr_goal = eth_goal)

  new_st = merge(st,
		  (pyruvate = goal.pyruvate,
		  acetate = acet_st.acetate,
		  ethanol = eth_st.ethanol,
		  co2 = acet_st.co2 + eth_st.co2 - st.co2,
		  water = acet_st.water))
  end

  function acetate_butyrate_fermentation(st; goal = (; pyruvate = 0.0))
  acet_goal = (; pyruvate = (st.pyruvate - (st.pyruvate - goal.pyruvate)*0.25))
  butyr_goal = (; pyruvate = (st.pyruvate - (st.pyruvate - goal.pyruvate)*0.75))

  acet_st = pyruv_to_acetate(st, goal = acet_goal)
  butyr_st = pyruv_to_butyr(st, goal = butyr_goal)

  new_st = merge(st,
		  (pyruvate = goal.pyruvate,
		  acetate = acet_st.acetate,
		  butyrate = butyr_st.butyrate,
		  hydrogen = acet_st.hydrogen + butyr_st.hydrogen - st.hydrogen,
		  co2 = acet_st.co2 + butyr_st.co2 - st.co2))
  end

  # Reminder that the pyruvate to propionate function has levers for how
  # much lactate was produced from each pathway and if lactate or
  # succinate are accumulated in the reactor. In the case of
  # acetate-propionate fermentation with this stoichiometry, propionate
  # is fully converted so these aren't necessary. More complex ones can
  # be defined to explain accumulation of lactate and succinate, but
  # this is the standard acidogenic route.
  function acetate_propionate_fermentation(st; pyr_goal = (; pyruvate = 0.0), lact_goal=(; lactate = 0.0), lact_amount = 1, prop_amount = 2/3)
      acet_goal = (; pyruvate = (st.pyruvate - (st.pyruvate - pyr_goal.pyruvate)*(1-prop_amount)))
      prop_goal = (; pyruvate = (st.pyruvate - (st.pyruvate - pyr_goal.pyruvate)*prop_amount))

      acet_st = pyruv_to_acetate(st, goal = acet_goal)
      prop_st = pyruv_to_propionate(st, lact_amount, pyr_goal = prop_goal, lact_goal = lact_goal)

      new_st = merge(st,
		     (pyruvate = pyr_goal.pyruvate,
		      acetate = acet_st.acetate,
		      propionate = prop_st.propionate,
		      co2 = acet_st.co2,
		      lactate = prop_st.lactate,
		      hydrogen = acet_st.hydrogen + prop_st.hydrogen - st.hydrogen))
  end

#+END_SRC

Besides these, there is another one, which I have not seen in literature but I have needed to accurately describe my experiments, which is the ethanol-propionate pathway. Due to both ethanol and propionate being pathways that need multiple reductions, this ends up needing a lot of hydrogen and as such is not commonly reported. But if there is a surplus of hydrogen from other processes, it can be used to describe a system and therefore is implemented here.

#+NAME: eth_prop
#+BEGIN_SRC julia :tangle ../src/metabolic_pathways/compound_pathways.jl

  function ethanol_propionate_fermentation(st; pyr_goal = (; pyruvate = 0.0),
					   lact_goal = (; lactate = 0.0),
					   succin_goal = (; succinate = 0.0),
					   prop_amount = 0.5, lact_amount = 1)
      eth_goal = (; pyruvate = (st.pyruvate - (st.pyruvate - pyr_goal.pyruvate)*(1-prop_amount)))
      prop_goal = (; pyruvate = (st.pyruvate - (st.pyruvate - pyr_goal.pyruvate)*prop_amount))

      eth_st = pyruv_to_ethanol(st, pyr_goal = eth_goal)
      prop_st = pyruv_to_propionate(st, lact_amount, pyr_goal = prop_goal, lact_goal = lact_goal, succin_goal = succin_goal)

      new_st = merge(st,
		     (pyruvate = pyr_goal.pyruvate,
		      ethanol = eth_st.ethanol,
		      propionate = prop_st.propionate,
		      lactate = prop_st.lactate,
		      co2 = eth_st.co2,
		      hydrogen = eth_st.hydrogen + prop_st.hydrogen - st.hydrogen,
		      succinate = prop_st.succinate))
  end

#+END_SRC

** ABE Fermentation
Another common pathway studied in literature is ABE fermentation. In this, there is an acidogenic phase where mostly acetate and butyrate are produced (with some ethanol production) and after some time, the culture enters the solventogenic phase where ethanol is produced with a higher yield and together with acetone and butanol. This system is described with the below, fairly complex, function. Note that the extent to which each product is produced is not set in stone for ABE fermentation so all of these are given as keyword arguments.

#+NAME: abe
#+BEGIN_SRC julia :tangle ../src/metabolic_pathways/compound_pathways.jl

  function ABE_fermentation(st; goal = (; pyruvate = 0.0),
			  acet_amount, aceteth_amount, butyr_amount,
			  solveth_amount, acetone_amount)
  butanol_amount = 1 - acet_amount - aceteth_amount - butyr_amount - solveth_amount - acetone_amount
  acet_goal = (; pyruvate = (st.pyruvate - (st.pyruvate - goal.pyruvate))*acet_amount)
  aceteth_goal = (; pyruvate = (st.pyruvate - (st.pyruvate - goal.pyruvate))*aceteth_amount)
  butyr_goal = (; pyruvate = (st.pyruvate - (st.pyruvate - goal.pyruvate))*butyr_amount)
  solveth_goal = (; pyruvate = (st.pyruvate - (st.pyruvate - goal.pyruvate))*solveth_amount)
  acetone_goal = (; pyruvate = (st.pyruvate - (st.pyruvate - goal.pyruvate))*acetone_amount)
  butanol_goal = (; pyruvate = (st.pyruvate - (st.pyruvate - goal.pyruvate))*butanol_amount)

  acet_st = pyruv_to_acetate(st, goal = acet_goal)
  aceteth_st = acetate_ethanol_fermentation(st, goal = aceteth_goal)
  butyr_st = pyruv_to_butyr(st, goal = butyr_goal)
  acidogenic_st = merge(st,
			  (pyruvate = acet_st.pyruvate + aceteth_st.pyruvate + butyr_st.pyruvate - 2st.pyruvate,
			  acetate = acet_st.acetate + aceteth_st.acetate - st.acetate,
			  butyrate = butyr_st.butyrate,
			  ethanol = aceteth_st.ethanol,
			  hydrogen = acet_st.hydrogen,
			  co2 = acet_st.co2 + aceteth_st.co2 + butyr_st.co2 - 2st.co2,
			  water = acet_st.water + aceteth_st.water - st.water))

  solveth_st = pyruv_to_ethanol(acidogenic_st, goal = solveth_goal)
  acetone_st = pyruv_to_acetone(acidogenic_st, goal = acetone_goal)
  butanol_st = pyruv_to_butanol(acidogenic_st, goal = butanol_goal)
  solventogenic_st = merge(acidogenic_st,
			      (pyruvate = goal.pyruvate,

			      ethanol = solveth_st.ethanol,
			      acetone = acetone_st.acetone,
			      butanol = butanol_st.butanol,
			      co2 = solveth_st.co2 + acetone_st.co2 + butanol_st.co2 - 2acidogenic_st.co2,
			      hydrogen = acetone_st.hydrogen + butanol_st.hydrogen - acidogenic_st.hydrogen,
			      water = acetone_st.water + butanol_st.water - acidogenic_st.water))
  end

#+END_SRC

* Test on experiments
This section is about a test for the experiments we have done to see if we can validate the data. Obviously, we first need to import dependencies and our data.

#+NAME: read_exp_data
#+BEGIN_SRC julia :tangle ../scripts/metabolic_tests.jl

  using DrWatson
  @quickactivate "Masters_Thesis"
  include(srcdir("filenames.jl"))
  include(srcdir("metabolic_pathways", "primitives.jl"))
  include(srcdir("metabolic_pathways", "core_pathways.jl"))
  include(srcdir("metabolic_pathways", "compound_pathways.jl"))
  include(srcdir("metabolic_pathways", "acetogenesis.jl"))
  using CSV, DataFrames

  # Read all the data
  exp_35 = "10_11"
  exp_40 = "28_11"
  mix_amount = ["0", "1", "2", "4", "8"]

  # Experiment @35 C
  df35_0 = CSV.read(get_conc_csv(exp_35, mix_amount[1]), DataFrame)
  df35_1 = CSV.read(get_conc_csv(exp_35, mix_amount[2]), DataFrame)
  df35_2 = CSV.read(get_conc_csv(exp_35, mix_amount[3]), DataFrame)
  df35_4 = CSV.read(get_conc_csv(exp_35, mix_amount[4]), DataFrame)
  df35_8 = CSV.read(get_conc_csv(exp_35, mix_amount[5]), DataFrame)

  # Experiment @40 C
  df40_0 = CSV.read(get_conc_csv(exp_40, mix_amount[1]), DataFrame)
  df40_1 = CSV.read(get_conc_csv(exp_40, mix_amount[2]), DataFrame)
  df40_2 = CSV.read(get_conc_csv(exp_40, mix_amount[3]), DataFrame)
  df40_4 = CSV.read(get_conc_csv(exp_40, mix_amount[4]), DataFrame)
  df40_8 = CSV.read(get_conc_csv(exp_40, mix_amount[5]), DataFrame)

#+END_SRC

Then, we need to initialize the named tuples this framework uses instead of the data frames.

#+NAME: tuple_initialization
#+BEGIN_SRC julia :tangle ../scripts/metabolic_tests.jl

  # 35 C
  v = 0.8
  init_st35_0 = (sucrose = df35_0.Sucrose[1], glucose = df35_0.Glucose[1],
	      fructose = df35_0.Fructose[1], lactate = df35_0.Lactate[2],
	      acetate = df35_0.Acetate[1], propionate = df35_0.Propionate[2],
	      ethanol = df35_0.Ethanol[1], co2 = 0.0, hydrogen = 0.0, water = 750.0,
	      pyruvate = 0.0, succinate = 0.0, acetaldehyde = 0.0)
  init_mass35_0 = conc_to_mass(init_st35_0, v)

  init_st35_1 = (sucrose = df35_1.Sucrose[1], glucose = df35_1.Glucose[1],
	      fructose = df35_1.Fructose[1], lactate = df35_1.Lactate[2],
	      acetate = df35_1.Acetate[2], propionate = df35_1.Propionate[2],
	      ethanol = df35_1.Ethanol[1], co2 = 0.0, hydrogen = 0.0, water = 750.0,
	      pyruvate = 0.0, succinate = 0.0, acetaldehyde = 0.0)
  init_mass35_1 = conc_to_mass(init_st35_1, v)

  init_st35_2 = (sucrose = df35_2.Sucrose[1], glucose = df35_2.Glucose[1],
	      fructose = df35_2.Fructose[1], lactate = df35_2.Lactate[1],
	      acetate = df35_2.Acetate[1], propionate = df35_2.Propionate[1],
	      ethanol = df35_2.Ethanol[1], co2 = 0.0, hydrogen = 0.0, water = 750.0,
	      pyruvate = 0.0, succinate = 0.0, acetaldehyde = 0.0)
  init_mass35_2 = conc_to_mass(init_st35_2, v)

  init_st35_4 = (sucrose = df35_4.Sucrose[1], glucose = df35_4.Glucose[1],
	      fructose = df35_4.Fructose[1], lactate = df35_4.Lactate[1],
	      acetate = df35_4.Acetate[2], propionate = df35_4.Propionate[1],
	      ethanol = df35_4.Ethanol[1], co2 = 0.0, hydrogen = 0.0, water = 750.0,
	      pyruvate = 0.0, succinate = 0.0, acetaldehyde = 0.0)
  init_mass35_4 = conc_to_mass(init_st35_4, v)

  init_st35_8 = (sucrose = df35_8.Sucrose[1], glucose = df35_8.Glucose[1],
	      fructose = df35_8.Fructose[1], lactate = df35_8.Lactate[1],
	      acetate = df35_8.Acetate[2], propionate = df35_8.Propionate[1],
	      ethanol = df35_8.Ethanol[1], co2 = 0.0, hydrogen = 0.0, water = 750.0,
	      pyruvate = 0.0, succinate = 0.0, acetaldehyde = 0.0)
  init_mass35_8 = conc_to_mass(init_st35_8, v)

  # 40C
  v = 0.8
  init_st40_0 = (sucrose = df40_0.Sucrose[1], glucose = df40_0.Glucose[1],
	      fructose = df40_0.Fructose[1], lactate = df40_0.Lactate[2],
	      acetate = df40_0.Acetate[1], propionate = df40_0.Propionate[2],
	      ethanol = df40_0.Ethanol[1], co2 = 0.0, hydrogen = 0.0, water = 750.0,
	      pyruvate = 0.0, succinate = 0.0, acetaldehyde = 0.0)
  init_mass40_0 = conc_to_mass(init_st40_0, v)

  init_st40_1 = (sucrose = df40_1.Sucrose[1], glucose = df40_1.Glucose[1],
	      fructose = df40_1.Fructose[1], lactate = df40_1.Lactate[2],
	      acetate = df40_1.Acetate[2], propionate = df40_1.Propionate[2],
	      ethanol = df40_1.Ethanol[1], co2 = 0.0, hydrogen = 0.0, water = 750.0,
	      pyruvate = 0.0, succinate = 0.0, acetaldehyde = 0.0)
  init_mass40_1 = conc_to_mass(init_st40_1, v)

  init_st40_2 = (sucrose = df40_2.Sucrose[1], glucose = df40_2.Glucose[1],
	      fructose = df40_2.Fructose[1], lactate = df40_2.Lactate[1],
	      acetate = df40_2.Acetate[1], propionate = df40_2.Propionate[1],
	      ethanol = df40_2.Ethanol[1], co2 = 0.0, hydrogen = 0.0, water = 750.0,
	      pyruvate = 0.0, succinate = 0.0, acetaldehyde = 0.0)
  init_mass40_2 = conc_to_mass(init_st40_2, v)

  init_st40_4 = (sucrose = df40_4.Sucrose[1], glucose = df40_4.Glucose[1],
	      fructose = df40_4.Fructose[1], lactate = df40_4.Lactate[1],
	      acetate = df40_4.Acetate[2], propionate = df40_4.Propionate[1],
	      ethanol = df40_4.Ethanol[1], co2 = 0.0, hydrogen = 0.0, water = 750.0,
	      pyruvate = 0.0, succinate = 0.0, acetaldehyde = 0.0)
  init_mass40_4 = conc_to_mass(init_st40_4, v)

  init_st40_8 = (sucrose = df40_8.Sucrose[1], glucose = df40_8.Glucose[1],
	      fructose = df40_8.Fructose[1], lactate = df40_8.Lactate[1],
	      acetate = df40_8.Acetate[2], propionate = df40_8.Propionate[1],
	      ethanol = df40_8.Ethanol[1], co2 = 0.0, hydrogen = 0.0, water = 750.0,
	      pyruvate = 0.0, succinate = 0.0, acetaldehyde = 0.0)
  init_mass40_8 = conc_to_mass(init_st40_8, v)


#+END_SRC

#+RESULTS: tuple_initialization
: (sucrose = 1.2456020570041368, glucose = 0.9088174478617946, fructose = 2.066122010164552, lactate = 0.6800897714442687, acetate = 0.429670080644349, propionate = 0.3521945102952011, ethanol = 0.04780181150792819, co2 = 0.0, hydrogen = 0.0, water = 600.0, pyruvate = 0.0, succinate = 0.0, acetaldehyde = 0.0)

** Parameterized final metabolic pathway
Then, we can define the compound reaction function that lists all the pathways we believe are occuring.

#+NAME: final_pathway
#+BEGIN_SRC julia :tangle ../scripts/metabolic_tests.jl

  function mixed_culture_fermentation(st; gluc_goal = (; glucose = 0.0), suc_goal = (; sucrose = 0.0), lact_cons_goal = (; lactate = 0.0), fruc_goal = (; fructose = 0.0), pyr_goal = (; pyruvate = 0.0), acet_amount = 0.5, lact_amount = 0.5, het_amount = 1.0, eth_amount = 0.0, feed_oxygen = 0.0)
      # Sucrose is hydrolyzed
      suc_st = sucrose_hydrolysis(st, goal = suc_goal)

      # Glucose goes into either glycolysis or heterolactic fermentation
      het_goal = (; glucose = (suc_st.glucose - (suc_st.glucose - gluc_goal.glucose)*het_amount))
      glyc_goal = (; glucose = (suc_st.glucose - (suc_st.glucose - gluc_goal.glucose)*(1-het_amount)))
      het_st = ethanol_heterolactate(suc_st, goal = het_goal)
      glyc_st = glycolysis(suc_st, goal = glyc_goal)

      pyr_st = merge(suc_st,
		     (glucose = gluc_goal.glucose,
		      ethanol = het_st.ethanol,
		      lactate = het_st.lactate,
		      co2 = het_st.co2,
		      pyruvate = het_st.pyruvate + glyc_st.pyruvate - suc_st.pyruvate,
		      hydrogen = het_st.hydrogen + glyc_st.hydrogen - suc_st.hydrogen))

      # Fructose is also hydrolyzed
      fruc_st = fructolysis(pyr_st, goal = fruc_goal)

      # Check if there is any oxygen in the reactor and if there is
      # consume the according pyruvate
      ox_st = merge(fruc_st, (; oxygen = feed_oxygen))
      new_st = aerobic_pyruvate_oxidation(ox_st)

      # Then, pyruvate is converted to the various products
      aceteth_amount = 1 - lact_amount - acet_amount - eth_amount
      acet_goal = (; pyruvate = (new_st.pyruvate - (new_st.pyruvate - pyr_goal.pyruvate)*acet_amount))
      lact_prod_goal = (; pyruvate = (new_st.pyruvate - (new_st.pyruvate - pyr_goal.pyruvate)*lact_amount))
      aceteth_goal = (; pyruvate = (new_st.pyruvate - (new_st.pyruvate - pyr_goal.pyruvate)*aceteth_amount))
      eth_goal = (; pyruvate = (new_st.pyruvate - (new_st.pyruvate - pyr_goal.pyruvate)*eth_amount))

      # We know that hydrogen will be produced by the reaction producing
      # acetate and consumed by the ones producing lactate and
      # ethanol. We also know that in some cases the fructolytic
      # hydrogen (which is the only hydrogen that exists in `new_st`)
      # may not be enough. For this reason, we precompute the hydrogen
      # that will be produced.
      acet_st = pyruv_to_acetate(new_st, goal = acet_goal)
      # Aceteth can also be computed here as its hydrogen neutral (one
      # reaction produces and one consumes) so its results will be the
      # same in either state.
      aceteth_st = acetate_ethanol_fermentation(new_st, goal = aceteth_goal)

      hyd_st = merge(new_st, (; hydrogen = acet_st.hydrogen))

      # Then compute the other 2 states with this hyd_st as the input.
      lact_st = pyruv_to_lact(hyd_st, goal = lact_prod_goal)
      eth_st = pyruv_to_ethanol(hyd_st, pyr_goal = eth_goal)

      # Then merge the 4 states with the initial one, taking care to
      # compute the correct hydrogen state.
      prod_st = merge(new_st,
		     (pyruvate = pyr_goal.pyruvate,
		      acetate = acet_st.acetate + aceteth_st.acetate - new_st.acetate,
		      ethanol = aceteth_st.ethanol + eth_st.ethanol - new_st.ethanol,
		      lactate = lact_st.lactate,
		      co2 = acet_st.co2 + aceteth_st.co2 + eth_st.co2 - 2new_st.co2,
		      hydrogen = lact_st.hydrogen + eth_st.hydrogen - hyd_st.hydrogen))

      # With this trick, we have circumvented the problem that hydrogen
      # may not be sufficient for all reactions if one doesn't recognize
      # the changes of the other (which is necessary to write the fluxes
      # this way) but have the same results as if all of them happened
      # at the same time.

      prop_st = lact_to_propionate(prod_st, goal = lact_cons_goal)
  end

#+END_SRC

#+RESULTS: final_pathway
: mixed_culture_fermentation (generic function with 1 method)

** Finding the true metabolic pathway
The above function is very useful. Given all its required parameters, it returns an output state of what it believes is the effluent concentrations. However, randomly trying parameters until our system starts looking correct isn't a good approach. What we want is to find the parameter set for which the function output matches the experimental data as much as possible, which can be formulated as a parameter estimation problem, which we can very easily solve with the SciML tooling. First, we need a function y = f(x,p) which given an input and a parameter set, returns an output. However, we want to have knowledge of the initial and final states, so we first a generalized function that does this work and while testing we can make it more specific to have the above signature. The next few code blocks are the backend which the optimization interface will use and for that reason it will be tangled to a src file and not to scripts. The function ~mixed_culture_fermentation~ defined above is necessary for this to work so it will also be tangled to that file.

*** Generic optimization function
#+NAME: opt_function
#+BEGIN_SRC julia :noweb no-export :tangle ../src/metabolic_pathways/opt_interface.jl

  <<final_pathway>>

  function mixed_culture_optimization(init_st, df, p, v)
      init_mass = conc_to_mass(init_st, v)
      final_st = Vector(df[4, 2:8])
      final_mass = final_st.*v
      mixed_culture_fermentation(init_mass, suc_goal = (; sucrose = final_mass[1]), gluc_goal = (; glucose = final_mass[2]), fruc_goal = (; fructose = final_mass[3]), lact_cons_goal = (; lactate = final_mass[4]), het_amount = p[1], acet_amount = p[2], lact_amount = p[3], eth_amount = p[4], feed_oxygen = p[5])
  end

#+END_SRC

#+RESULTS: opt_function
: mixed_culture_optimization (generic function with 1 method)

This function is a generalized function that does this exact thing. It takes an initial state that needs to be of the format ~mixed_culture_fermentation~ will accept, a dataframe whose first column is time and then has 7 other columns with the products and which has 4 rows, and a vector. The vector is one of 5 elements containing our parameters. The function that we will use in the final optimization will not have the dataframe as a parameter, but rather we will wrap that part inside a closure. In the same logic, we can write our loss function.

*** Calculating the loss of our experiments
However, before writing the loss function, one problem can be noted. Ethanol reaches a maximum during either 24 or 48 hours and after that starts decreasing. The decrease is easily explainable if we consider acetogenic reactions for it. The above does not consider them, so training on that data means overestimating the other acetogenic fluxes and having to train on ethanol that is not the final condition. Therefore, we need a function that takes the initial state and the dataframe containing final as well as intermediate states and returns how much acetogenesis changes each of the three variables we are training on. This is necessary as if we add the acetogenic reaction above, we risk never finding the maximum ethanol and the system predicting that ethanol acetogenesis happens only to a very small degree. For this reason we use this correction.

#+NAME: acetogenic_loss
#+BEGIN_SRC julia :tangle ../src/metabolic_pathways/opt_interface.jl

  function acetogenic_loss(init_st, df, v)
      eth_st = merge(init_st, (; ethanol = maximum(df[:, 8])))
      mass_st = conc_to_mass(eth_st, v)
      final_st = Vector(df[4, 2:8]).*v
      reaction = ethanol_to_acetate(mass_st, goal = (; ethanol = final_st[7]))
      acet_diff = mass_st.acetate - reaction.acetate
      prop_diff = mass_st.propionate - reaction.propionate
      eth_diff = mass_st.ethanol - reaction.ethanol

      return [acet_diff, prop_diff, eth_diff]
  end
#+END_SRC

#+RESULTS: acetogenic_loss
: acetogenic_loss (generic function with 2 methods)

This function will return a vector containing the difference in acetate, propionate and ethanol before and after ethanol acetogenesis. Propionate is obviously 0, but is added so we can directly add these to the final state. By subtracting initial from final, we get a positive one for ethanol and a negative one for acetate. This means, that we can get the final state from the dataframe (and not worry about getting ethanol at its peak), add to the final ethanol what was there before acetogenesis and remove from acetate what the acetogenic reaction will yield. This way, we can train on the data prior to acetogenesis and know that after it, we will get the final effluent.

However, this still has a problem. All the underlying functions that this system uses have rather verbose errors that inform you if you're about to select a parameter set that will yield an impossible reaction (a reactant's mass falling below 0). This is very useful while testing things to know where your limits are. However, in an optimization setting it is impractical and forces us to bound our optimization problem in an area where it will hopefully not error. For this reason, if ~fermentation_loss_calculator~ (which is the underlying function calculating the loss) returns any error (no need to check which reactant is not enough if there is at least 1), the loss will be 1 (which in an optimization setting is a value very far from 0). This allows the optimizer to run in a setting without boundaries, because if it goes beyond what is feasible, the optimizer will see a very high loss and will move in the opposite direction. This allows for convergence even through errors.

#+NAME: loss_function
#+BEGIN_SRC julia :tangle ../src/metabolic_pathways/opt_interface.jl

  function fermentation_loss_calculator(init_st, df, p, v)
      model = mixed_culture_optimization(init_st, df, p, v)
      final_st = Vector(df[4, 2:8])

      model_mass = [model.acetate, model.propionate, model.ethanol]
      exp_mass = final_st[5:7].*v
      exp_corrected = exp_mass .+ acetogenic_loss(init_st, df, v)
      sum(abs2, (model_mass .- exp_corrected))
  end

  # This function handles exceptions in the calculation of the
  # fermentation loss by saying if it errored, it has a high loss,
  # meaning it will not be selected.
  function fermentation_loss(init_st, df, p, v)
      try
	  fermentation_loss_calculator(init_st, df, p, v)
      catch
	  1.0
      end
  end

#+END_SRC

#+RESULTS: loss_function
: fermentation_loss (generic function with 1 method)

*** Defining a predictor function for the optimization
Lastly, we want a predictor function for use after optimization. The optimization problem simply returns the parameter vector, however, what we are interested in is what the output state looks like and its loss, besides the parameters. Using the same signature as above (initial_state being a named Tuple, df being a data frame, p being the parameter vector and v being volume) this predictor function returns that verbosely that the parameter set p, which it is given gives an effluent with these concentrations which when compared with experimental data gives this loss.

#+NAME: predictor_function
#+BEGIN_SRC julia :tangle ../src/metabolic_pathways/opt_interface.jl

  function mixed_culture_predictor(init_st, df, p, v)
      mass_st = mixed_culture_optimization(init_st, df, p, v)

      loss = fermentation_loss(init_st, df, p, v)

      acet_st = ethanol_to_acetate(mass_st, goal = (; ethanol = df[4, 8]*v))
      conc_st = mass_to_conc(acet_st, v)
      println("For the parameter set ", p, " we get the effluent \n", conc_st, " and a loss of ", loss, " with the experimental data.")
  end

#+END_SRC

#+RESULTS: predictor_function
: mixed_culture_predictor (generic function with 1 method)

*** Testing on a specific dataset
Now, we can test this system for a specific dataset. To do this, we will move back to the metabolic_tests.jl file, but include the optimization interface source.

Firstly, we need to specialize the loss and predictor to our specific dataset. We know the initial state, we know the dataframe we extract data from and we know that volume is 0.8 L. Note that to be consistent with the optimization interface of SciML, what we consider our problem's parameters (aka the things we are optimizing for) is the ~u~ vector while the ~p~ vector here signifies any known parameters of the model which we are not trying to estimate. There are none of these in our model (as we consider every parameter unknown) but there are many examples where this p is used and for that reason it is mandatory for the interface to work.

#+NAME: optimization_test
#+BEGIN_SRC julia :tangle ../scripts/metabolic_tests.jl

  include(srcdir("metabolic_pathways", "opt_interface.jl"))

  # Define the specialized loss function with signature f(u, p) which is
  # what the Optimization interface accepts and also a predictor
  # function which is also specialized and helps us with testing.
  loss_35_0(u, p) = fermentation_loss(init_st35_0, df35_0, u, 0.8)
  predictor_35_0(u) = mixed_culture_predictor(init_st35_0, df35_0, u, 0.8)

  using Optimization, OptimizationOptimJL

  # u0 can be taken basically randomly and if its not too bad, the
  # algorithm will converge.
  u0 = [0.89, 0.12, 0.09, 0.18, 0.86]

  # The bounds were originally necessary, as the system couldn't
  # converge outside of a very specific domain due to errors popping up,
  # but after introducing error handling and saying that we should
  # handle what would be an error by just attributing a high loss to it,
  # this isn't necessary. In this first demonstrative example however,
  # these bounds are kept to show that the problem with and without
  # bounds gives very similar results.
  lbound = [0.8, 0.0, 0.00, 0.0, 0.0]
  ubound = [1.0, 0.3, 0.3, 0.6, 2.0]

  adtype = Optimization.AutoForwardDiff()
  optf = Optimization.OptimizationFunction(loss_35_0, adtype)

  optprob = Optimization.OptimizationProblem(optf, u0, lb = lbound, ub = ubound)

  sol1 = solve(optprob, Optim.BFGS())
  predictor_35_0(sol1.u)

  # After adding error handling to the loss function, the optimizer will
  # reach the correct solution even without bounds and will not error
  # out in them.
  opt_unbound = Optimization.OptimizationProblem(optf, u0)

  # An interesting problem is that if this is ran with the above u0, it
  # fails to find the optimum. However, if a new u0 is defined, which is
  # closer to the solution of the bounded optimization problem, the
  # system will indeed converge. This shows that the optimizer without
  # bounds is more sensitive to initial conditions and care should be
  # taken to get a good result.
  sol2 = solve(opt_unbound, Optim.BFGS())
  # Returns failure

  # Rerun the problem with a slightly dislocated version of sol1
  new_prob = Optimization.OptimizationProblem(optf, sol1.u .+ 0.1.*rand())
  sol3 = solve(new_prob, Optim.BFGS())
  # Converges properly

  # Note that this isn't the exact same solution as sol1 (which is
  # expected as we are studying a very complex system which is very
  # likely to have multiple local minima), but since both have a very
  # small loss function and also are not far from each other, either one
  # can be accepted as correct.

  predictor_35_0(sol3.u)
#+END_SRC

#+RESULTS: optimization_test
: For the parameter set [0.8522911885236557, 0.010016639769404763, 0.19675408375133674, 0.5896492286155799, 1.1517112172093666] we get the effluent 
: (sucrose = 0.0, glucose = 0.0, fructose = 0.5698409419388468, lactate = 1.41121069870574, acetate = 0.9977001860043982, propionate = 0.6902132250514903, ethanol = 0.6578151430375364, co2 = 4.292157076536604, hydrogen = 0.2916445262905078, water = 748.5772823983715, pyruvate = 0.0, succinate = 0.0, acetaldehyde = 0.0, oxygen = 0.0) and a loss of 4.3738513920753965e-18 with the experimental data.
: For the parameter set [0.8529470058924152, 0.011958596731649293, 0.19638460326507223, 0.5916882137767437, 1.1517112172192296] we get the effluent 
: (sucrose = 0.0, glucose = 0.0, fructose = 0.5698409419388468, lactate = 1.41121069870574, acetate = 0.9977001859809786, propionate = 0.6902132250661184, ethanol = 0.6578151430375364, co2 = 4.292494613061103, hydrogen = 0.29164452629086274, water = 748.5772823978351, pyruvate = 0.0, succinate = 0.0, acetaldehyde = 0.0, oxygen = 0.0) and a loss of 1.7311763576329616e-18 with the experimental data.

The conclusion from the above study is that an unbounded optimization problem of this sort is very likely to converge to a good result, if given proper initial conditions, but in the case it is having difficulties to coverge, bounding it to a smaller domain helps a lot with convergence.

A very likely for difficulty of convergence is that the system gets multiple "illegal" parameter sets in a row (which all have a high loss) and as such it thinks it can't improve the system any more and gives the failure. Bounding it in an area where it is much less likely to hit errors (or starting from a good initial condition) guarantee convergence.

It should also be noted that a crude test was ran to check if a global optimizer like ParticleSwarm or a Genetic Algorithm can outperform BFGS. In general, global optimizers perform very well in some problems where they find the global minimum which has a loss than any other local minimum, but in the case of very complex optimization problems, they may be outperformed by algorithms that very efficiently find local minima. Due to the very low loss of the BFGS examples, it was expected that it's hard to outperform this. However, the test was done and these algorithms either didn't converge or converged to worse minima than BFGS, so this guess is probably the best we can make.

* Running the optimization routine for the other 9 experiments
After doing a test, we can now easily expand it to all experiments.

#+NAME: exp_35_1
#+BEGIN_SRC julia

  loss_35_1(u, p) = fermentation_loss(init_st35_1, df35_1, u, 0.8)
  predictor_35_1(u) = mixed_culture_predictor(init_st35_1, df35_1, u, 0.8)

  # First, let's try to solve an unbounded optimization problem using
  # the solution of the above as the initial condition.
  optf_35_1 = OptimizationFunction(loss_35_1, adtype)
  optprob_35_1 = OptimizationProblem(optf_35_1, sol1.u)

  sol35_1 = solve(optprob_35_1, Optim.BFGS())
#+END_SRC

#+RESULTS: exp_35_1
: retcode: Success
: u: 5-element Vector{Float64}:
:  0.8416447538491477
:  0.3756171533211556
:  0.10400937051757815
:  0.3086810188403601
:  1.565520103342531

Doesn't converge with what I tried so far, may need more work.
#+NAME: exp_35_2
#+BEGIN_SRC julia

  loss_35_2(u, p) = fermentation_loss(init_st35_2, df35_2, u, 0.8)
  predictor_35_2(u) = mixed_culture_predictor(init_st35_2, df35_2, u, 0.8)

  u0 = [0.85, 1e-5, 0.3, 0.5, 1.6]
  lbound = [0.6, 0.0, 0.0, 0.0, 1.5]
  ubound = [1.0, 0.05, 0.5, 0.9, 1.8]

  optf_35_2 = OptimizationFunction(loss_35_2, adtype)
  optprob_35_2 = OptimizationProblem(optf_35_2, u0, lb = lbound, ub = ubound)

  sol35_2 = solve(optprob_35_2, Optim.BFGS())
#+END_SRC

If ethanol goes to acetate when consumed and nothing else becomes acetate, it is still too large, which cause convergence problems in both this and the 8 ml one. However, if we do the little trick of replacing the final ethanol with the max, we can get perfect convergence. What this does essentially is circumvent acetogenesis because these 3 systems are in conditions where acetogenesis is not favoured. Ethanol is still consumed however, while leads us to the question of what could be consuming ethanol if not acetogens.
#+NAME: exp_35_4
#+BEGIN_SRC julia

  df35_4[4, 8] = df35_4[3, 8]
  loss_35_4(u, p) = fermentation_loss(init_st35_4, df35_4, u, 0.8)
  predictor_35_4(u) = mixed_culture_predictor(init_st35_4, df35_4, u, 0.8)

  u0 = [0.85, 1e-5, 0.3, 0.5, 1.3]
  lbound = [0.6, 0.0, 0.0, 0.0, 1.0]
  ubound = [1.0, 0.05, 0.5, 0.9, 1.8]

  optf_35_4 = OptimizationFunction(loss_35_4, adtype)
  optprob_35_4 = OptimizationProblem(optf_35_4, u0, lb = lbound, ub = ubound)

  sol35_4 = solve(optprob_35_4, Optim.BFGS())
#+END_SRC

#+RESULTS: exp_35_4
: retcode: Success
: u: 5-element Vector{Float64}:
:  0.7204567048845205
:  0.02358710953122682
:  0.12353465276749778
:  0.7306294220795058
:  1.3827795632743047

#+NAME: exp_35_8
#+BEGIN_SRC julia

  df35_8[4, 8] = df35_8[2, 8]
  loss_35_8(u, p) = fermentation_loss(init_st35_8, df35_8, u, 0.8)
  predictor_35_8(u) = mixed_culture_predictor(init_st35_8, df35_8, u, 0.8)

  u0 = [0.85, 1e-5, 0.3, 0.5, 1.3]
  lbound = [0.6, 0.0, 0.0, 0.0, 1.0]
  ubound = [1.0, 0.05, 0.5, 0.9, 1.8]

  optf_35_8 = OptimizationFunction(loss_35_8, adtype)
  optprob_35_8 = OptimizationProblem(optf_35_8, u0, lb= lbound, ub = ubound)

  sol35_8 = solve(optprob_35_8, Optim.BFGS())
#+END_SRC

#+RESULTS: exp_35_8
: retcode: Success
: u: 5-element Vector{Float64}:
:  0.8357030960301777
:  0.023904958571613472
:  0.18990019981849252
:  0.5898812306251663
:  1.1903514568271203

#+NAME: exp_40_0
#+BEGIN_SRC julia

  loss_40_0(u, p) = fermentation_loss(init_st40_0, df40_0, u, 0.8)
  predictor_40_0(u) = mixed_culture_predictor(init_st40_0, df40_0, u, 0.8)

  u0 = [0.85, 0.16, 0.1, 1e-5, 0.3]
  lbound = [0.8, 0.0, 0.0, 0.0, 0.0]
  ubound = [1.0, 0.3, 0.3, 0.1, 1.0]

  optf_40_0 = OptimizationFunction(loss_40_0, adtype)
  optprob_40_0 = OptimizationProblem(optf_40_0, u0, lb = lbound, ub = ubound)

  sol40_0 = solve(optprob_40_0, Optim.BFGS())
#+END_SRC

#+RESULTS: exp_40_0
: retcode: Success
: u: 5-element Vector{Float64}:
:  0.8256910842322117
:  0.28152564106697336
:  0.060235085862184394
:  0.01600376015947915
:  0.47081194872942334

#+NAME: exp_40_1
#+BEGIN_SRC julia

  loss_40_1(u, p) = fermentation_loss(init_st40_1, df40_1, u, 0.8)
  predictor_40_1(u) = mixed_culture_predictor(init_st40_1, df40_1, u, 0.8)

  u0 = [0.89, 0.16, 0.1, 0.1, 0.3]
  lbound = [0.8, 0.0, 0.0, 0.0, 0.0]
  ubound = [1.0, 0.5, 0.5, 0.3, 1.5]

  optf_40_1 = OptimizationFunction(loss_40_1, adtype)
  optprob_40_1 = OptimizationProblem(optf_40_1, u0, lb = lbound, ub = ubound)

  sol40_1 = solve(optprob_40_1, Optim.BFGS())
#+END_SRC

#+RESULTS: exp_40_1
: retcode: Success
: u: 5-element Vector{Float64}:
:  0.8151164910171266
:  0.4760034761169193
:  0.41813720146861383
:  0.02301220468762658
:  1.3072081152868809

#+NAME: exp_40_2
#+BEGIN_SRC julia

  loss_40_2(u, p) = fermentation_loss(init_st40_2, df40_2, u, 0.8)
  predictor_40_2(u) = mixed_culture_predictor(init_st40_2, df40_2, u, 0.8)

  u0 = [0.85, 0.45, 0.5, 0.03, 1.0]
  lbound = [0.8, 0.0, 0.0, 0.0, 0.0]
  ubound = [1.0, 0.5, 0.6, 0.3, 1.5]

  optf_40_2 = OptimizationFunction(loss_40_2, adtype)
  optprob_40_2 = OptimizationProblem(optf_40_2, u0, lb = lbound, ub = ubound)

  sol40_2 = solve(optprob_40_2, Optim.BFGS())
#+END_SRC

#+RESULTS: exp_40_2
: retcode: Success
: u: 5-element Vector{Float64}:
:  0.8787543062367564
:  0.37694871502126504
:  0.5150118997259585
:  0.09629679880937857
:  0.7990511201741595

#+NAME: exp_40_4
#+BEGIN_SRC julia

  loss_40_4(u, p) = fermentation_loss(init_st40_4, df40_4, u, 0.8)
  predictor_40_4(u) = mixed_culture_predictor(init_st40_4, df40_4, u, 0.8)

  u0 = [0.85, 0.45, 0.50, 0.03, 1.0]
  lbound = [0.8, 0.0, 0.0, 0.0, 0.0]
  ubound = [1.0, 0.5, 0.6, 0.3, 1.5]

  optf_40_4 = OptimizationFunction(loss_40_4, adtype)
  optprob_40_4 = OptimizationProblem(optf_40_4, u0, lb = lbound, ub = ubound)

  sol40_4 = solve(optprob_40_4, Optim.BFGS())
#+END_SRC

#+RESULTS: exp_40_4
: retcode: Success
: u: 5-element Vector{Float64}:
:  0.8071982555587044
:  0.4903277346669905
:  0.49036012306288185
:  0.009532470719328907
:  1.266797414186493

#+NAME: exp_40_8
#+BEGIN_SRC julia

  loss_40_8(u, p) = fermentation_loss(init_st40_8, df40_8, u, 0.8)
  predictor_40_8(u) = mixed_culture_predictor(init_st40_8, df40_8, u, 0.8)

  u0 = [0.85, 0.3, 0.50, 0.03, 0.8]
  lbound = [0.7, 0.0, 0.0, 0.0, 0.0]
  ubound = [1.0, 0.4, 0.7, 0.3, 1.5]

  optf_40_8 = OptimizationFunction(loss_40_8, adtype)
  optprob_40_8 = OptimizationProblem(optf_40_8, u0, lb = lbound, ub = ubound)

  sol40_8 = solve(optprob_40_8, Optim.BFGS())
#+END_SRC

#+RESULTS: exp_40_8
: retcode: Success
: u: 5-element Vector{Float64}:
:  0.7040720317861947
:  0.39670059826916304
:  0.5704193684634057
:  0.0032933880109850457
:  0.9993243340672121

